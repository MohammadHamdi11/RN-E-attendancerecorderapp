scanner:
// Database reference
const db = SQLite.openDatabase('qrscanner.db');
// Add a message state to show online/offline status
const [connectionMessage, setConnectionMessage] = useState('');
// Update connection message when online status changes
useEffect(() => {
if (isOnline) {
setConnectionMessage('Online - All features available');
// If we're back online and there's a session that needs to be backed up remotely
if (activeSession && !activeSession.backedUp) {
setScanStatus('Back online - Session will be backed up automatically');
// Process any pending backups when coming online
processPendingBackups()
.then(result => {
if (result && result.processed > 0) {
setScanStatus(`Processed ${result.processed} pending backups`);
// Clear message after a timeout
setTimeout(() => {
setScanStatus('');
}, 5000);
} else {
// Clear any "will be backed up when online" messages
setScanStatus('');
}
})
.catch(error => console.error("Error processing pending backups:", error));
} else {
// Clear any "will be backed up when online" messages
setScanStatus('');
}
// Check for pending backups when coming online
checkAndProcessPendingBackups();
} else {
setConnectionMessage('Offline - Working in local mode');
}
}, [isOnline, activeSession]);
// Request camera permission when component mounts
useEffect(() => {
(async () => {
const { status } = await BarCodeScanner.requestPermissionsAsync();
setHasPermission(status === 'granted');
})();
// Create tables if they don't exist
db.transaction(tx => {
tx.executeSql(
'CREATE TABLE IF NOT EXISTS sessions (id TEXT PRIMARY KEY, location TEXT, dateTime TEXT, inProgress INTEGER)'
);
tx.executeSql(
'CREATE TABLE IF NOT EXISTS scans (id INTEGER PRIMARY KEY AUTOINCREMENT, sessionId TEXT, content TEXT, time TEXT, isManual INTEGER, FOREIGN KEY (sessionId) REFERENCES sessions (id))'
);
});
// Initialize scanner module
initializeScannerModule();
return () => {
if (sound) {
sound.unloadAsync();
}
};
}, []);
// Initialize scanner module
const initializeScannerModule = async () => {
console.log("Initializing scanner module...");
// Check for recoverable session
await checkForRecoverableScannerSession();
// Load sessions from storage
const savedSessions = await AsyncStorage.getItem('sessions');
if (savedSessions) {
setSessions(JSON.parse(savedSessions));
}
// Make sure the pendingBackups array exists
AsyncStorage.getItem('pendingBackups').then(pendingBackups => {
if (!pendingBackups) {
AsyncStorage.setItem('pendingBackups', JSON.stringify([]));
console.log("Initialized empty pendingBackups array");
}
});
}; 
// Check and process pending backups when coming online
const checkAndProcessPendingBackups = async () => {
if (!isOnline) {
console.log("Cannot process backups while offline");
return;
}
try {
console.log("Checking for pending backups...");
// setScanStatus('Checking for pending backups...');  // Removed UI update
const result = await processPendingBackups();
console.log("Process pending backups result:", result);
if (result.success) {
if (result.message.includes('processed')) {
// setScanStatus(result.message);  // Removed UI update
// Refresh sessions to update backup status
const savedSessions = await AsyncStorage.getItem('sessions');
if (savedSessions) {
// setSessions(JSON.parse(savedSessions));  // Removed UI update
}
}
}
} catch (error) {
console.error('Error processing pending backups:', error);
// setScanStatus('Error processing backups');  // Removed UI update
}
};
// Add this function to ScannerScreen.js
const markSessionAsCompleted = async (sessionId) => {
try {
// Update session in AsyncStorage
const savedSessions = await AsyncStorage.getItem('sessions');
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === sessionId);
if (sessionIndex !== -1) {
// Update session status
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {
...updatedSessions[sessionIndex],
inProgress: false
};
// Save updated sessions
await AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
setSessions(updatedSessions);
console.log(`Session ${sessionId} marked as completed`);
}
}
// Also update SQLite database for backward compatibility
db.transaction(tx => {
tx.executeSql(
'UPDATE sessions SET inProgress = 0 WHERE id = ?',
[sessionId]
);
});
// Clear recovery data
await AsyncStorage.removeItem(TEMP_SCANNER_SESSION_INDEX_KEY);
} catch (error) {
console.error("Error marking session as completed:", error);
}
};
// Check for recoverable scanner session
const checkForRecoverableScannerSession = async () => {
try {
// Check for active session
const savedActiveSession = await AsyncStorage.getItem(SCANNER_ACTIVE_SESSION_STORAGE_KEY);
if (savedActiveSession) {
const parsedSession = JSON.parse(savedActiveSession);
if (parsedSession && parsedSession.id && parsedSession.scans) {
Alert.alert(
"Recover Session",
`Found an incomplete scanner session at ${parsedSession.location} with ${parsedSession.scans.length} scans. Would you like to recover it?`,
[
{
text: "Yes",
onPress: () => recoverScannerSession(parsedSession)
},
{
text: "No",
onPress: () => {
const sessionId = parsedSession.id;
markSessionAsCompleted(sessionId);
clearActiveScannerSession();
}
}
]
);
return;
}
}
// Check for in-progress session in history
const tempSessionIndex = await AsyncStorage.getItem(TEMP_SCANNER_SESSION_INDEX_KEY);
if (tempSessionIndex !== null) {
const allSessions = await AsyncStorage.getItem('sessions');
if (allSessions) {
const parsedSessions = JSON.parse(allSessions);
const index = parseInt(tempSessionIndex);
if (!isNaN(index) && index >= 0 && index < parsedSessions.length) {
const tempSession = parsedSessions[index];
if (tempSession && tempSession.inProgress) {
Alert.alert(
"Recover Session",
`Found an incomplete scanner session at ${tempSession.location} with ${tempSession.scans.length} scans in history. Would you like to recover it?`,
[
{
text: "Yes",
onPress: () => recoverScannerSession(tempSession)
},
{
text: "No",
onPress: () => {
const sessionId = tempSession.id;
markSessionAsCompleted(sessionId);
AsyncStorage.removeItem(TEMP_SCANNER_SESSION_INDEX_KEY);
}
}
]
);
}
}
}
}
// If no recoverable session, load from database as fallback
if (!savedActiveSession && tempSessionIndex === null) {
loadActiveSession();
}
} catch (error) {
console.error("Error checking for recoverable session:", error);
clearActiveScannerSession();
// Fallback to database
loadActiveSession();
}
};
// Recover scanner session
const recoverScannerSession = (session) => {
// Set active session
setActiveSession(session);
setScans(session.scans || []);
setScanStatus('Session recovered - Ready to scan');
// Check if session exists in sessions array
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === session.id);
if (sessionIndex === -1) {
// Add session to sessions array
const updatedSessions = [...parsedSessions, session];
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
// Store temp index
const newIndex = updatedSessions.length - 1;
AsyncStorage.setItem(TEMP_SCANNER_SESSION_INDEX_KEY, String(newIndex));
} else {
// Update existing session
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {...session};
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
AsyncStorage.setItem(TEMP_SCANNER_SESSION_INDEX_KEY, String(sessionIndex));
}
} else {
// Create new sessions array
const newSessions = [session];
setSessions(newSessions);
AsyncStorage.setItem('sessions', JSON.stringify(newSessions));
AsyncStorage.setItem(TEMP_SCANNER_SESSION_INDEX_KEY, '0');
}
});
// Save active session
saveActiveScannerSession(session);
// Also save to SQLite for backward compatibility
syncSessionToDatabase(session);
console.log("Scanner session recovered successfully");
};
// Sync session to SQLite database (for backward compatibility)
const syncSessionToDatabase = (session) => {
if (!session) return;
db.transaction(tx => {
// First check if session exists
tx.executeSql(
'SELECT * FROM sessions WHERE id = ?',
[session.id],
(_, { rows }) => {
if (rows.length === 0) {
// Insert new session
tx.executeSql(
'INSERT INTO sessions (id, location, dateTime, inProgress) VALUES (?, ?, ?, ?)',
[session.id, session.location, session.dateTime, 1]
);
} else {
// Update existing session
tx.executeSql(
'UPDATE sessions SET location = ?, dateTime = ?, inProgress = ? WHERE id = ?',
[session.location, session.dateTime, 1, session.id]
);
}
// Clear existing scans for this session
tx.executeSql(
'DELETE FROM scans WHERE sessionId = ?',
[session.id],
() => {
// Insert each scan
if (session.scans && session.scans.length > 0) {
session.scans.forEach(scan => {
tx.executeSql(
'INSERT INTO scans (sessionId, content, time, isManual) VALUES (?, ?, ?, ?)',
[session.id, scan.content, scan.timestamp, scan.isManual ? 1 : 0]
);
});
}
}
);
}
);
});
};
// Save active session to storage
const saveActiveScannerSession = (session = activeSession) => {
if (session) {
AsyncStorage.setItem(SCANNER_ACTIVE_SESSION_STORAGE_KEY, JSON.stringify(session))
.then(() => console.log("Active scanner session saved:", session.id))
.catch(error => console.error("Error saving active scanner session:", error));
}
};
// Clear active session from storage
const clearActiveScannerSession = () => {
AsyncStorage.removeItem(SCANNER_ACTIVE_SESSION_STORAGE_KEY)
.then(() => AsyncStorage.removeItem(TEMP_SCANNER_SESSION_INDEX_KEY))
.then(() => console.log("Active scanner session cleared from storage"))
.catch(error => console.error("Error clearing active scanner session:", error));
};
// Load active session from database (legacy method)
const loadActiveSession = () => {
db.transaction(tx => {
tx.executeSql(
'SELECT * FROM sessions WHERE inProgress = 1',
[],
(_, { rows }) => {
if (rows.length > 0) {
const session = rows._array[0];
// Load scans for this session
tx.executeSql(
'SELECT * FROM scans WHERE sessionId = ? ORDER BY id',
[session.id],
(_, { rows: scanRows }) => {
const formattedScans = scanRows._array.map(scan => ({
id: scan.id,
content: scan.content,
timestamp: scan.time,
formattedTime: formatTime(new Date(scan.time)),
isManual: scan.isManual
}));
const formattedSession = {
...session,
formattedDateTime: formatDateTime(new Date(session.dateTime)),
scans: formattedScans
};
setActiveSession(formattedSession);
setScans(formattedScans);
setScanStatus('Session loaded - Ready to scan');
// Also save to AsyncStorage for recovery
saveActiveScannerSession(formattedSession);
}
);
}
}
);
});
};
// Play success sound
async function playSuccessSound() {
try {
// First check if file exists
const fileInfo = await FileSystem.getInfoAsync(
FileSystem.documentDirectory + 'beep.mp3'
);
let soundObject;
if (fileInfo.exists) {
// Use file from document directory
const { sound } = await Audio.Sound.createAsync({ uri: fileInfo.uri });
soundObject = sound;
} else {
// Use bundled asset - corrected path
const { sound } = await Audio.Sound.createAsync(require('../assets/beep.mp3'));
soundObject = sound;
}
setSound(soundObject);
await soundObject.playAsync();
} catch (error) {
console.error('Error playing sound:', error);
// Continue without sound if there's an error
}
}
// Start new session
const startSession = () => {
if (!location.trim()) {
Alert.alert('Error', 'Please enter a location');
return;
}
const now = new Date();
const sessionId = `session_${now.getTime()}`;
const formattedDateTime = formatDateTime(now);
const newSession = {
id: sessionId,
location: location,
dateTime: now.toISOString(),
formattedDateTime: formattedDateTime,
scans: [],
inProgress: true
};
// Set active session
setActiveSession(newSession);
setScans([]);
setShowSessionModal(false);
setScanStatus('Session started - Ready to scan');
// Add session to sessions array
AsyncStorage.getItem('sessions').then(savedSessions => {
const parsedSessions = savedSessions ? JSON.parse(savedSessions) : [];
const updatedSessions = [...parsedSessions, newSession];
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
// Store temp index
const index = updatedSessions.length - 1;
AsyncStorage.setItem(TEMP_SCANNER_SESSION_INDEX_KEY, String(index));
});
// Save active session
saveActiveScannerSession(newSession);
// Also save to SQLite for backward compatibility
db.transaction(tx => {
tx.executeSql(
'INSERT INTO sessions (id, location, dateTime, inProgress) VALUES (?, ?, ?, ?)',
[sessionId, location, now.toISOString(), 1],
null,
(_, error) => {
console.error('Error starting session in database:', error);
}
);
});
console.log("New scanner session created:", sessionId);
};
// End current session
const endSession = () => {
if (!activeSession) return;
Alert.alert(
'End Session',
'Are you sure you want to end the current session?',
[
{ text: 'Cancel', style: 'cancel' },
{ 
text: 'End Session', 
style: 'destructive',
onPress: () => {
finalizeSession();
}
}
]
);
};
// Queue session for backup when offline
const queueSessionForBackup = async (session) => {
try {
console.log("Queueing session for backup:", session.id);
// Get existing pending backups
const pendingBackups = await AsyncStorage.getItem('pendingBackups');
const backupsArray = pendingBackups ? JSON.parse(pendingBackups) : [];
// Generate a proper file name
const fileName = `Scanner_${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Add this session to pending backups
backupsArray.push({
timestamp: new Date().toISOString(),
session: session,
fileName: fileName,
type: 'scanner'
});
// Save updated pending backups
await AsyncStorage.setItem('pendingBackups', JSON.stringify(backupsArray));
console.log(`Session queued for backup. Total pending: ${backupsArray.length}`);
// Display status message about offline backup
setScanStatus(`Session saved offline. Will be backed up when online.`);
// Show alert with offline backup information
Alert.alert(
"Session Saved Offline",
"This session has been saved offline and will be backed up automatically when you're back online.",
[{ text: "OK" }]
);
} catch (error) {
console.error("Error queueing session for backup:", error);
Alert.alert("Backup Error", "Failed to queue session for later backup.");
}
};
// Finalize session
const finalizeSession = () => {
if (!activeSession) return;
// Save session for export
const sessionToExport = { ...activeSession };
// Mark session as completed in history
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {
...updatedSessions[sessionIndex],
inProgress: false,
backedUp: isOnline // Mark if backed up based on connection status
};
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
// If offline, queue for backup
if (!isOnline) {
console.log("App is offline, queueing session for backup");
queueSessionForBackup(sessionToExport);
} else {
console.log("App is online, attempting immediate backup");
// Try to backup immediately
try {
backupToGitHub([sessionToExport], false)
.then(result => {
console.log("Backup result:", result);
if (result && result.success) {
// Set last backup time to now
const now = new Date();
AsyncStorage.setItem(LAST_BACKUP_TIME_KEY, now.toISOString())
.then(() => console.log("Last backup time updated"));
// Show success message for online backup
Alert.alert("Backup Success", "Session backed up to GitHub successfully!");
} else {
console.error("Backup failed:", result);
// Only show alert if it's not an empty workbook error
if (!result.message || !result.message.includes('empty')) {
Alert.alert("Backup Failed", "Unable to backup to GitHub. The session is saved locally.");
} else {
console.log("Empty workbook - skipping backup silently");
}
}
})
.catch(error => {
console.error("Backup error:", error);
// Only show alert if it's not an empty workbook error
if (!error.message.includes('Workbook is empty')) {
Alert.alert("Backup Error", `Error during backup: ${error.message}`);
} else {
console.log("Empty workbook - skipping backup silently");
}
});
} catch (error) {
console.error("Exception during backup:", error);
// Don't show alert for empty workbook errors
if (!error.message.includes('Workbook is empty')) {
Alert.alert("Backup Error", `Exception during backup: ${error.message}`);
}
}
}
}
}
});
// Also update SQLite for backward compatibility
db.transaction(tx => {
tx.executeSql(
'UPDATE sessions SET inProgress = 0 WHERE id = ?',
[activeSession.id]
);
});
// Clear active session
setActiveSession(null);
setScans([]);
setScanStatus('');
clearActiveScannerSession();
// Export session to Excel
if (sessionToExport && sessionToExport.scans && sessionToExport.scans.length > 0) {
setTimeout(() => {
exportScannerSession(sessionToExport);
}, 500);
}
Alert.alert('Success', 'Session ended successfully');
console.log("Scanner session ended successfully");
};
// Export scanner session to Excel
const exportScannerSession = async (session) => {
try {
const fileName = `Scanner_${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Prepare data
const data = [
['Number', 'Content', 'Location', 'Log Date', 'Log Time', 'Type']
];
// Add scans with row numbers
session.scans.forEach((scan, index) => {
const scanDate = new Date(scan.timestamp);
data.push([
index + 1,                   // Row number
scan.content,                // Scanned content
session.location,            // Location
formatDate(scanDate),        // Log Date
formatTime(scanDate),        // Log Time
scan.isManual ? 'Manual' : 'Scan'  // Type
]);
});
// Create workbook
const ws = XLSX.utils.aoa_to_sheet(data);
const wb = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(wb, ws, "Scanner");
// Convert to binary
const wbout = XLSX.write(wb, { type: 'base64', bookType: 'xlsx' });
// Save file
const filePath = `${FileSystem.documentDirectory}${fileName}`;
await FileSystem.writeAsStringAsync(filePath, wbout, {
encoding: FileSystem.EncodingType.Base64
});
// Show success message
Alert.alert("Export Successful",
`Scanner data saved as ${fileName}. ${!isOnline ? "The file will be backed up when you're back online." : ""}`
);
console.log("Scanner Excel file saved:", fileName);
} catch (error) {
console.error("Error exporting scanner session:", error);
Alert.alert("Export Error", "Failed to export scanner data: " + error.message);
}
};
// Handle barcode scanning
const handleBarCodeScanned = ({ type, data }) => {
if (!activeSession || scanned) return;
setScanned(true);
processScannedCode(data, false);
// Allow scanning again after a short delay
setTimeout(() => {
setScanned(false);
}, 2000);
};
// Process scanned or manually entered code
const processScannedCode = (data, isManual = false) => {
if (!data || !activeSession) {
console.log("Cannot process scan: No data or no active session");
return;
}
// Trim data to handle extra spaces
const cleanData = data.trim();
if (!cleanData) {
console.log("Cannot process scan: Empty data after trimming");
return;
}
console.log(`Processing ${isManual ? 'manual entry' : 'scan'}: ${cleanData}`);
// Check if already scanned in this session
const alreadyScanned = scans.some(scan => scan.content === cleanData);
if (alreadyScanned) {
setScanStatus(`Already scanned: ${cleanData.substring(0, 20)}${cleanData.length > 20 ? '...' : ''}`);
return;
}
const now = new Date();
const timestamp = now.toISOString();
const formattedTime = formatTime(now);
// Create new scan
const newScan = {
id: Date.now().toString(),
content: cleanData,
timestamp: timestamp,
formattedTime: formattedTime,
time: now,
isManual: isManual
};
// Update scans state
const updatedScans = [...scans, newScan];
setScans(updatedScans);
// Update active session
const updatedSession = {
...activeSession,
scans: updatedScans
};
setActiveSession(updatedSession);
// Save to AsyncStorage
saveActiveScannerSession(updatedSession);
updateSessionInHistory(updatedSession);
// Also save to SQLite for backward compatibility
db.transaction(tx => {
tx.executeSql(
'INSERT INTO scans (sessionId, content, time, isManual) VALUES (?, ?, ?, ?)',
[activeSession.id, cleanData, timestamp, isManual ? 1 : 0],
(_, result) => {
console.log(`Scan saved to database with ID: ${result.insertId}`);
},
(_, error) => {
console.error('Error saving scan to database:', error);
}
);
});
// Try to play success sound but continue if it fails
try {
playSuccessSound();
} catch (e) {
console.log("Could not play sound, continuing without sound");
}
// Update status
setScanStatus(`✅ ${isManual ? 'Manual entry' : 'Scanned'}: ${cleanData.substring(0, 20)}${cleanData.length > 20 ? '...' : ''}`);
console.log(`${isManual ? 'Manual entry' : 'Scan'} processed successfully: ${cleanData}`);
};
// Update session in history
const updateSessionInHistory = (updatedSession) => {
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === updatedSession.id);
if (sessionIndex !== -1) {
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {...updatedSession};
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
}
}
});
};
// Process manual entry
const processManualEntry = () => {
const studentId = manualId.trim();
if (!studentId) {
Alert.alert('Error', 'Please enter a Student ID');
return;
}
// Process the manual entry
processScannedCode(studentId, true);
// Close modal and reset input
setShowManualEntryModal(false);
setManualId('');
// Update UI with status
setScanStatus(`✅ Manual entry added: ${studentId.substring(0, 20)}${studentId.length > 20 ? '...' : ''}`);
console.log(`Manual entry processed: ${studentId}`);
};
checklist:
return (
<View style={styles.studentItem}>
<Checkbox.Item
label={`${studentId} (${studentYear}, Group ${studentGroup})`}
status={isSelected ? 'checked' : 'unchecked'}
onPress={() => onToggle(studentId)}
/>
</View>
);
});
const SelectedStudentItem = React.memo(({ item, index }) => (
<View style={styles.selectionItem}>
<Text style={styles.selectionNumber}>{index + 1}</Text>
<Text style={styles.selectionId}>{item.id}</Text>
<Text style={styles.selectionTime}>{item.formattedTime}</Text>
</View>
));
// Storage keys
const CHECKLIST_ACTIVE_SESSION_STORAGE_KEY = 'activeChecklistSession';
const TEMP_CHECKLIST_SESSION_INDEX_KEY = 'tempChecklistSessionIndex';
const ChecklistScreen = ({ isOnline }) => {
// State variables
const [activeSession, setActiveSession] = useState(null);
const [studentsData, setStudentsData] = useState([]);
const [selectedStudents, setSelectedStudents] = useState(new Set());
const [searchQuery, setSearchQuery] = useState('');
const [showSessionModal, setShowSessionModal] = useState(false);
const [showManualEntryModal, setShowManualEntryModal] = useState(false);
const [manualId, setManualId] = useState('');
const [location, setLocation] = useState('');
const [yearFilter, setYearFilter] = useState('all');
const [groupFilter, setGroupFilter] = useState('all');
const [sessions, setSessions] = useState([]);
const [filteredStudents, setFilteredStudents] = useState([]);
const [connectionMessage, setConnectionMessage] = useState('');
const [selectionStatus, setSelectionStatus] = useState('');
const [checkliststatus, setcheckliststatus] = useState('');
// Debug connection status
useEffect(() => {
console.log("isOnline prop value:", isOnline);
// Test network connection
const testConnection = async () => {
try {
const response = await fetch('https://www.google.com', { 
method: 'HEAD',
timeout: 3000
});
const actuallyOnline = (response.status >= 200 && response.status < 300);
console.log("Fetch test result:", actuallyOnline ? "Online" : "Offline");
} catch (error) {
console.log("Fetch test failed:", error.message);
}
};
testConnection();
}, [isOnline]);
// Add this effect to check for pending backups when coming online
useEffect(() => {
if (isOnline) {
// Process any pending backups when we come back online
processPendingBackups()
.then(result => {
if (result && result.processed > 0) {
setcheckliststatus(`Processed ${result.processed} pending backups`);
}
})
.catch(error => console.error("Error processing pending backups:", error));
}
}, [isOnline]); // This will run whenever isOnline changes
useEffect(() => {
// Debounce search for better performance
const timeoutId = setTimeout(() => {
filterStudents();
}, 300); // 300ms delay
return () => clearTimeout(timeoutId);
}, [searchQuery, yearFilter, groupFilter, studentsData]);
// Then remove the filterStudents call from the original useEffect
useEffect(() => {
// Empty - actual filtering now happens in the debounced effect above
}, [searchQuery, yearFilter, groupFilter, studentsData]);
// Location options for the session location dropdown
const locationOptions = [
"Morgue",
"Anatomy Lecture Hall",
"Histology Lab",
"Histology Lecture Hall",
"Biochemistry Lab",
"Biochemistry Lecture Hall",
"Physiology Lab",
"Physiology Lecture Hall",
"Microbiology Lab",
"Microbiology Lecture Hall",
"Parasitology Lab",
"Parasitology Lecture Hall",
"Pathology Lab",
"Pathology Lecture Hall",
"Pharmacology Lab",
"Pharmacology Lecture Hall",
"Building 'A' Lecture Hall",
"Building 'B' Lecture Hall"
];
// Add these state variables
const [showYearFilterModal, setShowYearFilterModal] = useState(false);
const [showGroupFilterModal, setShowGroupFilterModal] = useState(false);
// Then add these functions to handle filters
const handleYearFilter = (year) => {
setYearFilter(year);
setShowYearFilterModal(false);
};
const handleGroupFilter = (group) => {
setGroupFilter(group);
setShowGroupFilterModal(false);
};
// Make sure the pendingBackups array exists
AsyncStorage.getItem('pendingBackups').then(pendingBackups => {
if (!pendingBackups) {
AsyncStorage.setItem('pendingBackups', JSON.stringify([]));
console.log("Initialized empty pendingBackups array");
}
});
// Check and process pending backups when coming online
const checkAndProcessPendingBackups = async () => {
if (!isOnline) {
console.log("Cannot process backups while offline");
return;
}
try {
console.log("Checking for pending backups...");
// setcheckliststatus('Checking for pending backups...');  // Removed UI update
const result = await processPendingBackups();
console.log("Process pending backups result:", result);
if (result.success) {
if (result.message.includes('processed')) {
// setcheckliststatus(result.message);  // Removed UI update
// Refresh sessions to update backup status
const savedSessions = await AsyncStorage.getItem('sessions');
if (savedSessions) {
// setSessions(JSON.parse(savedSessions));  // Removed UI update
}
}
}
} catch (error) {
console.error('Error processing pending backups:', error);
// setcheckliststatus('Error processing backups');  // Removed UI update
}
};
// Update connection message when online status changes
useEffect(() => {
if (isOnline) {
setConnectionMessage('Online - All features available');
// If we're back online and there's a session that needs to be backed up remotely
if (activeSession && !activeSession.backedUp) {
setSelectionStatus('Back online - Session will be backed up automatically');
// Process any pending backups when we come back online
processPendingBackups()
.then(result => {
if (result && result.processed > 0) {
setSelectionStatus(`Processed ${result.processed} pending backups`);
// Clear message after a timeout
setTimeout(() => {
setSelectionStatus('');
}, 5000);
} else {
// Clear any "will be backed up when online" messages
setSelectionStatus('');
}
})
.catch(error => console.error("Error processing pending backups:", error));
} else {
// Clear any "will be backed up when online" messages
setSelectionStatus('');
}
// Check for pending backups when coming online
checkAndProcessPendingBackups();
} else {
setConnectionMessage('Offline - Working in local mode');
}
}, [isOnline, activeSession]);
// Load initial data on component mount
useEffect(() => {
initializeChecklistModule();
}, []);
// Filter students when search query or filters change
useEffect(() => {
filterStudents();
}, [searchQuery, yearFilter, groupFilter, studentsData]);
// Initialize checklist module
const initializeChecklistModule = async () => {
console.log("Initializing checklist module...");
// Load students data
await loadStudentsDataForChecklist();
// Check for recoverable session
await checkForRecoverableChecklistSession();
// Load sessions from storage
const savedSessions = await AsyncStorage.getItem('sessions');
if (savedSessions) {
setSessions(JSON.parse(savedSessions));
}
};
// Load students data
const loadStudentsDataForChecklist = async () => {
try {
console.log("Loading students data...");
// First, try to use cached data
const cachedData = await AsyncStorage.getItem('cachedStudentsData');
if (cachedData) {
try {
const parsedData = JSON.parse(cachedData);
if (parsedData && parsedData.length > 0) {
console.log(`Using cached student data with ${parsedData.length} records`);
setcheckliststatus(`Loaded ${parsedData.length} student records from cache`);
// Transform cached data
const transformedData = formatStudentData(parsedData);
setStudentsData(transformedData);
// Optional: Check for updates in background if online
if (isOnline) {
checkForUpdatesInBackground();
}
return;
}
} catch (parseError) {
console.error("Error parsing cached data:", parseError);
}
}
// If no valid cached data, then try to load from network
const netState = await NetInfo.fetch();
const isConnected = netState.isConnected && netState.isInternetReachable;
if (isConnected) {
console.log("Device is connected to the internet");
setcheckliststatus("Online - Loading student data");
try {
// Get data from loadStudentsData function
const data = await loadStudentsData(false); // Use false to allow caching
if (data && data.length > 0) {
console.log(`Loaded student data with ${data.length} records`);
setcheckliststatus(`Loaded ${data.length} student records`);
// Save to cache explicitly
await AsyncStorage.setItem('cachedStudentsData', JSON.stringify(data));
console.log("Saved data to cache for future use");
// Transform the data
const transformedData = formatStudentData(data);
setStudentsData(transformedData);
return;
}
} catch (loadError) {
console.error("Error loading fresh student data:", loadError);
setcheckliststatus("Error loading data - Trying cached data");
}
} else {
console.log("Device is offline");
setcheckliststatus("Offline - Cannot load new student data");
}
// If we get here, we couldn't get valid data from cache or network
// As a last resort, use the built-in LOCAL_STUDENTS_DATA if available
console.warn("No student data available - online or cached");
setStudentsData([]);
setcheckliststatus("No student data available");
// Show alert to user about missing data
Alert.alert(
"No Student Data",
"Unable to load student data. Please connect to the internet and try again.",
[{ text: "OK" }]
);
} catch (error) {
console.error("Critical error in loadStudentsDataForChecklist:", error);
setStudentsData([]);
setcheckliststatus("Error loading student data");
}
};
// Helper function to check for updates in background
const checkForUpdatesInBackground = async () => {
try {
console.log("Checking for student data updates in background...");
setcheckliststatus("Checking for updates in background...");
// Use the existing function but force a reload
const data = await loadStudentsData(true);
if (data && data.length > 0) {
// Save to cache
await AsyncStorage.setItem('cachedStudentsData', JSON.stringify(data));
// Update UI if there's new data
const transformedData = formatStudentData(data);
setStudentsData(transformedData);
setcheckliststatus(`Updated to ${data.length} student records`);
console.log("Background update complete");
}
} catch (error) {
console.error("Background update failed:", error);
// Don't update status as this is a background operation
}
};
// Add this helper function to format student data consistently
const formatStudentData = (data) => {
// Transform the data to make sure we have consistent field names
const transformedData = [];
const seenIds = new Set();
data.forEach(student => {
const studentId = student["Student ID"] || student.id || "";
// If this ID hasn't been seen before, add it to the transformed data
if (studentId && !seenIds.has(studentId)) {
seenIds.add(studentId);
transformedData.push({
id: studentId,
year: student["Year"] || student.year || "",
group: student["Group"] || student.group || "",
// Keep the original fields too
"Student ID": studentId,
"Year": student["Year"] || student.year || "",
"Group": student["Group"] || student.group || ""
});
}
});
return transformedData;
};
// Check for recoverable session
const checkForRecoverableChecklistSession = async () => {
try {
// Check for active session
const savedActiveSession = await AsyncStorage.getItem(CHECKLIST_ACTIVE_SESSION_STORAGE_KEY);
if (savedActiveSession) {
const parsedSession = JSON.parse(savedActiveSession);
if (parsedSession && parsedSession.id && parsedSession.scans && parsedSession.isChecklist) {
Alert.alert(
"Recover Session",
`Found an incomplete checklist session at ${parsedSession.location} with ${parsedSession.scans.length} selections. Would you like to recover it?`,
[
{
text: "Yes",
onPress: () => recoverChecklistSession(parsedSession)
},
{
text: "No",
onPress: () => {
// Clear the active session
clearActiveChecklistSession();
// Also update the session in history to mark it as not in progress
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === parsedSession.id);
if (sessionIndex !== -1) {
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex].inProgress = false;
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions))
.then(() => console.log("Session marked as not in progress after recovery declined"))
.catch(error => console.error("Error updating session status:", error));
}
}
}).catch(error => console.error("Error updating session in storage:", error));
}
}
]
);
return;
}
}
// Check for in-progress session in history
const tempSessionIndex = await AsyncStorage.getItem(TEMP_CHECKLIST_SESSION_INDEX_KEY);
if (tempSessionIndex !== null) {
const allSessions = await AsyncStorage.getItem('sessions');
if (allSessions) {
const parsedSessions = JSON.parse(allSessions);
const index = parseInt(tempSessionIndex);
if (!isNaN(index) && index >= 0 && index < parsedSessions.length) {
const tempSession = parsedSessions[index];
if (tempSession && tempSession.inProgress && tempSession.isChecklist) {
Alert.alert(
"Recover Session",
`Found an incomplete checklist session at ${tempSession.location} with ${tempSession.scans.length} selections in history. Would you like to recover it?`,
[
{
text: "Yes",
onPress: () => recoverChecklistSession(tempSession)
},
{
text: "No",
onPress: () => {
const updatedSessions = [...parsedSessions];
updatedSessions[index].inProgress = false;
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions))
.then(() => {
AsyncStorage.removeItem(TEMP_CHECKLIST_SESSION_INDEX_KEY);
console.log("Session marked as not in progress after recovery declined");
})
.catch(error => {
console.error("Error updating session status:", error);
});
}
}
]
);
}
}
}
}
} catch (error) {
console.error("Error checking for recoverable session:", error);
clearActiveChecklistSession();
}
};
// Recover checklist session
const recoverChecklistSession = (session) => {
// Set active session
setActiveSession(session);
// Restore selections
const selectedSet = new Set();
session.scans.forEach(scan => {
selectedSet.add(scan.id);
});
setSelectedStudents(selectedSet);
setSelectionStatus('Session recovered - Ready to select students');
// Check if session exists in sessions array
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === session.id);
if (sessionIndex === -1) {
// Add session to sessions array
const updatedSessions = [...parsedSessions, session];
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
// Store temp index
const newIndex = updatedSessions.length - 1;
AsyncStorage.setItem(TEMP_CHECKLIST_SESSION_INDEX_KEY, String(newIndex));
} else {
// Update existing session
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {...session};
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
AsyncStorage.setItem(TEMP_CHECKLIST_SESSION_INDEX_KEY, String(sessionIndex));
}
} else {
// Create new sessions array
const newSessions = [session];
setSessions(newSessions);
AsyncStorage.setItem('sessions', JSON.stringify(newSessions));
AsyncStorage.setItem(TEMP_CHECKLIST_SESSION_INDEX_KEY, '0');
}
});
// Save active session
saveActiveChecklistSession(session);
console.log("Checklist session recovered successfully");
};
// Save active session to storage
const saveActiveChecklistSession = (session = activeSession) => {
if (session) {
AsyncStorage.setItem(CHECKLIST_ACTIVE_SESSION_STORAGE_KEY, JSON.stringify(session))
.then(() => console.log("Active session saved:", session.id))
.catch(error => console.error("Error saving active session:", error));
}
};
// Clear active session from storage
const clearActiveChecklistSession = () => {
AsyncStorage.removeItem(CHECKLIST_ACTIVE_SESSION_STORAGE_KEY)
.then(() => AsyncStorage.removeItem(TEMP_CHECKLIST_SESSION_INDEX_KEY))
.then(() => console.log("Active session cleared from storage"))
.catch(error => console.error("Error clearing active session:", error));
};
// Filter students based on search query and filters
const filterStudents = () => {
if (studentsData.length === 0) {
setFilteredStudents([]);
return;
}
// Only filter if there are actual filters active
if (searchQuery === '' && yearFilter === 'all' && groupFilter === 'all') {
setFilteredStudents(studentsData.slice(0, 200)); // Limit to first 200 students for performance
return;
}
// Otherwise do filtering
const filtered = studentsData.filter(student => {
const studentId = student["Student ID"] || student.id || "";
const studentYear = student["Year"] || student.year || "";
const studentGroup = student["Group"] || student.group || "";
const matchesSearch = searchQuery === '' || 
studentId.toString().toLowerCase().includes(searchQuery.toLowerCase());
const matchesYear = yearFilter === 'all' || studentYear === yearFilter;
const matchesGroup = groupFilter === 'all' || studentGroup === groupFilter;
return matchesSearch && matchesYear && matchesGroup;
});
// Limit results for performance
setFilteredStudents(filtered.slice(0, 200));
};
// Start a new checklist session
const startChecklistSession = () => {
setLocation('');
setShowSessionModal(true);
};
// Create a new checklist session
const createNewChecklistSession = () => {
console.log("Create session button pressed"); // Add this line
if (!location.trim()) {
Alert.alert("Error", "Please enter a location");
return;
}
// Create new session
const now = new Date();
const sessionId = `checklist_${now.getTime()}`;
const formattedDateTime = formatDateTime(now);
const newSession = {
id: sessionId,
location: location,
dateTime: now.toISOString(),
formattedDateTime: formattedDateTime,
scans: [],
inProgress: true,
isChecklist: true
};
// Set active session
setActiveSession(newSession);
// Clear selected students
setSelectedStudents(new Set());
setShowSessionModal(false);
setSelectionStatus('Session started - Ready to select students');
// Add session to sessions array
AsyncStorage.getItem('sessions').then(savedSessions => {
const parsedSessions = savedSessions ? JSON.parse(savedSessions) : [];
const updatedSessions = [...parsedSessions, newSession];
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
// Store temp index
const index = updatedSessions.length - 1;
AsyncStorage.setItem(TEMP_CHECKLIST_SESSION_INDEX_KEY, String(index));
});
// Save active session
saveActiveChecklistSession(newSession);
console.log("New checklist session created:", sessionId);
};
// Handle student selection
const handleStudentSelection = (studentId, isChecked) => {
if (!activeSession) return;
// Create new set to avoid direct mutation
const updatedSelection = new Set(selectedStudents);
if (isChecked) {
// Add student to selected set
updatedSelection.add(studentId);
addStudentToSelectionTable(studentId);
} else {
// Remove student from selected set
updatedSelection.delete(studentId);
removeStudentFromSelectionTable(studentId);
}
setSelectedStudents(updatedSelection);
};
const handleSyncData = async () => {
setcheckliststatus('Syncing student data with server...');
try {
const result = await syncStudentsDataWithGitHub();
if (result.success) {
setcheckliststatus(`Sync successful! Loaded ${result.count} students.`);
await loadStudentsDataForChecklist();
Alert.alert(
"Sync Complete",
`Successfully synchronized ${result.count} student records from the server.`
);
} else {
setcheckliststatus('Sync failed. Please try again later.');
Alert.alert(
"Sync Failed",
`Unable to sync with server: ${result.error}`
);
}
} catch (error) {
console.error('Error during manual sync:', error);
setcheckliststatus('Sync error. Please check your connection.');
Alert.alert(
"Sync Error",
"An unexpected error occurred during synchronization. Please check your internet connection and try again."
);
}
};
// Add student to selection table
const addStudentToSelectionTable = (studentId, isManual = false) => {
if (!activeSession) return;
// Create timestamp
const now = new Date();
const timestamp = now.toISOString();
const formattedTime = formatTime(now);
// Create new scan
const newScan = {
id: studentId,
content: studentId,
timestamp: timestamp,
formattedTime: formattedTime,
time: now,
isManual: isManual // Track if this was manually entered
};
// Update active session
const updatedSession = {
...activeSession,
scans: [...activeSession.scans, newScan]
};
setActiveSession(updatedSession);
// Save updated session
saveActiveChecklistSession(updatedSession);
updateSessionInHistory(updatedSession);
// Update status
setSelectionStatus(`✓ ${isManual ? 'Manually added' : 'Selected'}: ${studentId}`);
};
// Remove student from selection table
const removeStudentFromSelectionTable = (studentId) => {
if (!activeSession) return;
// Filter out scans for this student
const updatedScans = activeSession.scans.filter(scan => scan.id !== studentId);
// Update active session
const updatedSession = {
...activeSession,
scans: updatedScans
};
setActiveSession(updatedSession);
// Save updated session
saveActiveChecklistSession(updatedSession);
updateSessionInHistory(updatedSession);
// Update status
setSelectionStatus(`✗ Removed: ${studentId}`);
};
// Update session in history
const updateSessionInHistory = (updatedSession) => {
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === updatedSession.id);
if (sessionIndex !== -1) {
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {...updatedSession};
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
}
}
});
};
// Process manual entry
const processManualEntry = () => {
const studentId = manualId.trim();
if (!studentId) {
Alert.alert('Error', 'Please enter a Student ID');
return;
}
// Check if already selected
if (selectedStudents.has(studentId)) {
Alert.alert('Already Selected', `Student ${studentId} is already in your selection.`);
setShowManualEntryModal(false);
setManualId('');
return;
}
// Add to selected students
handleStudentSelection(studentId, true);
// Add to selection table with isManual flag
addStudentToSelectionTable(studentId, true);
// Close modal and reset input
setShowManualEntryModal(false);
setManualId('');
// Update status
setSelectionStatus(`✓ Manually added: ${studentId}`);
console.log(`Manual entry processed: ${studentId}`);
};
// End checklist session
const endChecklistSession = () => {
if (!activeSession) {
console.log("No active checklist session to end");
return;
}
console.log("Ending checklist session:", activeSession.id);
// Confirm if there are no selections
if (activeSession.scans.length === 0) {
Alert.alert(
"End Session",
"No students selected in this session. Do you still want to end it?",
[
{
text: "Yes",
onPress: () => finalizeChecklistSession()
},
{
text: "No"
}
]
);
} else {
Alert.alert(
'End Session',
'Are you sure you want to end the current session?',
[
{ text: 'Cancel', style: 'cancel' },
{ 
text: 'End Session', 
style: 'destructive',
onPress: () => finalizeChecklistSession()
}
]
);
}
};
// Finalize the checklist session
const finalizeChecklistSession = () => {
// Create a copy of the session for export
const sessionToExport = { ...activeSession };
// Mark session as completed in history
AsyncStorage.getItem('sessions').then(savedSessions => {
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {
...updatedSessions[sessionIndex],
inProgress: false,
backedUp: isOnline // Mark if backed up based on connection status
};
setSessions(updatedSessions);
AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
}
}
}).catch(error => {
console.error("Error updating session in storage:", error);
});
// Clear active session
setActiveSession(null);
setSelectedStudents(new Set());
setSelectionStatus('');
clearActiveChecklistSession();
// Show alert
Alert.alert('Success', 'Session ended successfully');
console.log("Checklist session ended successfully");
// Export session to Excel only if there are scans
if (sessionToExport && sessionToExport.scans && sessionToExport.scans.length > 0) {
setTimeout(() => {
if (!isOnline) {
// If offline, queue for backup instead of immediate export
queueSessionForBackup(sessionToExport);
} else {
exportChecklistSession(sessionToExport);
}
}, 500);
}
};
// Update backup status in UI and storage
const updateBackupStatus = async (sessionId, isBackedUp) => {
try {
// Update in storage
const savedSessions = await AsyncStorage.getItem('sessions');
if (savedSessions) {
const parsedSessions = JSON.parse(savedSessions);
const sessionIndex = parsedSessions.findIndex(s => s.id === sessionId);
if (sessionIndex !== -1) {
// Update backup status and timestamp
const updatedSessions = [...parsedSessions];
updatedSessions[sessionIndex] = {
...updatedSessions[sessionIndex],
backedUp: isBackedUp,
backupTimestamp: isBackedUp ? new Date().toISOString() : null
};
// Save to storage
await AsyncStorage.setItem('sessions', JSON.stringify(updatedSessions));
// Update in state
setSessions(updatedSessions);
console.log(`Session ${sessionId} backup status updated: ${isBackedUp}`);
}
}
} catch (error) {
console.error("Error updating backup status:", error);
}
};
// Queue session for backup when offline
const queueSessionForBackup = async (session) => {
try {
console.log("Queueing checklist session for backup:", session.id);
// Get existing pending backups
const pendingBackups = await AsyncStorage.getItem('pendingBackups');
const backupsArray = pendingBackups ? JSON.parse(pendingBackups) : [];
// Generate a proper file name for this checklist session
const fileName = `Checklist_${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Add this session to pending backups with checklist-specific metadata
backupsArray.push({
timestamp: new Date().toISOString(),
session: session,
fileName: fileName,
type: 'checklist', // Mark this as a checklist session explicitly
retryCount: 0
});
// Save updated pending backups
await AsyncStorage.setItem('pendingBackups', JSON.stringify(backupsArray));
console.log(`Checklist session queued for backup. Total pending: ${backupsArray.length}`);
// Display status message about offline backup
setSelectionStatus(`Session saved offline. Will be backed up when online.`);
// Show alert with offline backup information
Alert.alert(
"Session Saved Offline",
"This session has been saved offline and will be backed up automatically when you're back online.",
[{ text: "OK" }]
);
} catch (error) {
console.error("Error queueing checklist session for backup:", error);
Alert.alert("Backup Error", "Failed to queue checklist session for later backup.");
}
};
// Export checklist session to Excel
const exportChecklistSession = async (session) => {
try {
const fileName = `Checklist_${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Prepare data
const data = [
['Number', 'Student ID', 'Location', 'Log Date', 'Log Time', 'Type'] // Added Type column
];
// Add scans with row numbers
session.scans.forEach((scan, index) => {
const scanDate = new Date(scan.time || scan.timestamp);
data.push([
index + 1,            // Row number
scan.content,         // Student ID
session.location,     // Location
formatDate(scanDate), // Log Date
formatTime(scanDate), // Log Time
scan.isManual ? 'Manual' : 'Scan'  // Add type column to indicate manual entries
]);
});
// Create workbook
const ws = XLSX.utils.aoa_to_sheet(data);
const wb = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(wb, ws, "Checklist");
// Convert to binary
const wbout = XLSX.write(wb, { type: 'base64', bookType: 'xlsx' });
// Save file locally (works offline)
const filePath = `${FileSystem.documentDirectory}${fileName}`;
await FileSystem.writeAsStringAsync(filePath, wbout, {
encoding: FileSystem.EncodingType.Base64
});
console.log("Checklist Excel file saved:", fileName);
// Add backup logic for when online
if (isOnline) {
// Try to backup immediately if online
try {
await backupToGitHub([session], false, fileName);
console.log("Checklist backed up successfully");
// Update backup status in UI and storage
await updateBackupStatus(session.id, true);
// Add this code to update the last backup time
await BackupService.getLastBackupTime();
// Show success message for online backup
Alert.alert(
"Backup Successful",
"Checklist session has been successfully backed up to GitHub.",
[{ text: "OK" }]
);
} catch (backupError) {
console.error("Error backing up checklist:", backupError);
// Queue for later retry
const pendingBackups = await AsyncStorage.getItem('pendingBackups') || '[]';
const backupsArray = JSON.parse(pendingBackups);
backupsArray.push({
session: session,
fileName: fileName,
timestamp: new Date().toISOString(),
type: 'checklist',
retryCount: 1,
error: backupError.message
});
await AsyncStorage.setItem('pendingBackups', JSON.stringify(backupsArray));
}
}
// Show success message
Alert.alert(
"Export Successful",
`Checklist data saved as ${fileName}. ${!isOnline ? "The file will be backed up when you're back online." : ""}`
);
return true;
} catch (error) {
console.error("Error exporting checklist session:", error);
Alert.alert("Export Error", "Failed to export checklist: " + error.message);
return false;
}
};
// Helper functions for date/time formatting
const formatDateTime = (date) => {
return `${formatDate(date)} ${formatTime(date)}`;
};
const formatDate = (date) => {
return date.toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' });
};
const formatTime = (date) => {
return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
};
const formatDateTimeForFile = (date) => {
return date.toISOString().replace(/[:.]/g, '-').slice(0, 19);
};
// Get unique years and groups for filters
const getUniqueYears = useMemo(() => {
const years = new Set();
studentsData.forEach(student => {
const studentYear = student["Year"] || student.year;
if (studentYear) {
years.add(studentYear);
}
});
return Array.from(years).sort();
}, [studentsData]);
const getUniqueGroups = useMemo(() => {
const groups = new Set();
studentsData.forEach(student => {
const studentGroup = student["Group"] || student.group;
if (studentGroup) {
groups.add(studentGroup);
}
});
return Array.from(groups).sort();
}, [studentsData]);
// Filter students when search query or filters change - improved with memoization
const filteredStudentsMemo = useMemo(() => {
if (studentsData.length === 0) {
return [];
}
// Only filter if there are actual filters active
if (searchQuery === '' && yearFilter === 'all' && groupFilter === 'all') {
return studentsData.slice(0, 200); // Limit to first 200 students for performance
}
// Otherwise do filtering
const filtered = studentsData.filter(student => {
const studentId = student["Student ID"] || student.id || "";
const studentYear = student["Year"] || student.year || "";
const studentGroup = student["Group"] || student.group || "";
const matchesSearch = searchQuery === '' || 
studentId.toString().toLowerCase().includes(searchQuery.toLowerCase());
const matchesYear = yearFilter === 'all' || studentYear === yearFilter;
const matchesGroup = groupFilter === 'all' || studentGroup === groupFilter;
return matchesSearch && matchesYear && matchesGroup;
});
// Limit results for performance
return filtered.slice(0, 200);
}, [studentsData, searchQuery, yearFilter, groupFilter]);
// Update the filtered students when the memoized value changes
useEffect(() => {
setFilteredStudents(filteredStudentsMemo);
}, [filteredStudentsMemo]);